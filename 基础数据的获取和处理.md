# 基础数据的获取和处理

> 中韩PM2.5传导关系的验证

## 一、数据需求说明

在本项目中，我们需要覆盖研究区域的以下自然环境信息：

* 气象数据：地面温度T, 地表气压P, 风速WindSpeed, 相对湿度RH
* 自然地理数据：NDVI（标准化植被指数）, DEM（数字高程模型）
* 区域地理信息（城市，行政区域和陆地边界等）
* 空气污染信息：PM2.5观测站数据

其中气象信息随着时间的推移会产生变化，存在着时空尺度上的差异，需要按照时间逐一来处理。而自然地理的情况在我们的研究时间范围内几乎没有变化，即不存在时间尺度上的差异。

## 二、数据来源和预处理

#### 1. 区域地理信息

区域地理信息根据网络上的世界地图来获取。

![](assets/image-20190726105751061.png)

#### 2. 气象数据

气象数据的来源为NCDC（美国国家气候数据中心，National Climatic Data Center），隶属于NOAA（美国国家海洋及大气管理局，National Oceanic and Atmospheric Administration）。

数据来自NCDC的公开FTP服务器[Link](ftp://ftp.ncdc.noaa.gov/pub/data/noaa/isd-lite/)。气象数据按照站点和年分文件保存。这些气象要素包含了气温、气压、露点温度、风向风速、云量、降水量等。我们按照数据的规格说明，编写Python小程序进行数据处理，形成按时间分别储存的研究区域范围内所有的气象站的测站得到的读数信息（一个文件/要素集包含了某一个时间所有测站的地理位置和读数）。

#### 3. 自然地理数据

DEM数据来自[地理空间数据云](www.gscloud.cn)，经过重新裁剪和镶嵌，然后重采样选取和底图数据一样的栅格大小。

![地理空间数据云获取DEM数据界面截图](assets/clip_image002.png)

NDVI数据来源来自NASA的地球数据目录。见于 MODIS 数据中的MOD13 数据机，其中 A1 为 NDVI 值。[Link](https://ladsweb.modaps.eosdis.nasa.gov/search/)数据经过裁剪镶嵌，重采样最终被代入AOD的计算公式中。

![NASA Earth Data 获取NDVI信息截图](assets/clip_image004.png)



#### 4. 空气污染信息

获取到的PM2.5数据是按照时间整理的数据表格，每个表格包含了所有的监测点的坐标和PM2.5的值。



## 三、处理并获取覆盖地表的气象信息

根据Xintong Li和Qingqing He等的研究，我们选取以下变量进行处理和分析（这些变量并不一定用于建立PM2.5浓度的预测模型中）。

* 地表温度 (Surface Air Temperature, *T*)
* 露点温度 (Dew Point Temperature, *DT*)
* 相对湿度 (Relative Humidity, *RH*)
* 海平面气压 (Sea Level Air Pressure, *P*)
* 地表风速 (Wind Speed, *WS*)

其中，相对湿度的信息并没有在测站的读数中直接表达，而相对湿度取决于某一地点的T和DT。我们将按照物理学上对相对湿度的定义，利用测站获取的露点温度和气温气压，简单计算获得了相对湿度信息。

### 获取区域全覆盖的气象信息（插值）

 利用QGIS 3.8提供的的IDW工具，我们可以将研究区域内的点信息通过插值获得覆盖全面的气象信息。QGIS提供了Python IDE，名为PyQGIS，其中包括了`Processing`包，用于调用QGIS的空间处理组建。

利用空间插值方法，和气象信息这些信息，即可获得覆盖区域的气象信息。空间插值主要有三种常见的方法，一种是IDW，另外即是克里金法 (Krigging)、样条插值 (Spline Interpolation)。

#### Inverse Distance Weighting Interpolation

反距离加权(IDW)方法是一种确定性的空间插值模型，由于在许多GIS包中得到了实现，是目前地球科学工作者和地理学家广泛采用的方法之一。该方法的一般前提是任意给定一对点的属性值是相互关联的，但它们的相似度与两个位置之间的距离成反比。

然而，许多研究，特别是在空间相互作用的文献中，已经揭示了任何两个地点之间空间关系的下降并不仅仅与距离成正比。所以，距离的幂函数和指数函数常常被用于表示空间上地点之间的关联。应用IDW时，这类方程经常被用于预测确定地点的不确定要素值。

但是IDW也有一些缺陷，例如IDW的权重系数取决于一个固定的值 (priori) 而非根据实验和经验决定的。另外IDW不能预测没有样本数值的地点的值的方差。另外距离衰减参数 (distance-decay parameter) 在整个研究平面内都是均匀的，不考虑样本的数值的分布——换句话说，标准的IDW认为距离衰减在在空间中都是表现出一样的性质，但这不一定符合实际。相对而言，IDW提供的结果不够准确。



## 四、将气象信息和PM2.5观测站点进行空间关联

首先使用PyQGIS将所有的文本数据表格（csv文件）组织成地理信息系统支持的文件（shapefile）。然后使用QGIS提供的Add Raster Value to Point工具将之前获得的空间插值后的覆盖研究区域的气象数据空间关联到之前的shapefile中即可。





## 附录 处理代码

### 1. 对气象站的原始信息进行处理

使用Python对气象站原始信息进行整理，获得按时刻整理的csv文件组，每一个csv文件存放了研究区域内所有的气象站在对应的时刻的气象信息读数。

```python
import os
import csv
import re

dir = os.path.dirname(__file__)
datadir = os.path.join(dir, 'data')
outputDirectory = os.path.join(dir, 'output')
print(dir)
files = []
station_list = {}

with open('need.csv', newline='') as csvfile:
    station_list_csv = csv.reader(csvfile, delimiter=',', quotechar='\"')
    for row in station_list_csv:
        station_list[row[1]] = [row[7], row[8], row[9]]
del station_list['USAF']

weatherByHourList = []
for i in range(13, 19):    # day of date
    for j in range(0, 24, 3):
        fileName = ('201903{:0>2d}'.format(i) + '{:0>2d}').format(j)
        weatherByHourList.append(fileName)
        with open('output/' + fileName + '.csv', 'w', ) as file:
            file.write('USAF, lat, lon, ELEV, AirTemp, DewPointTemp, SeaLevelPressure, WindDirection, WindSpeedRate, SkyCondition, Precipitation\n')
            file.close()

for entry in os.listdir(os.path.join(dir, 'data')):
    usaf = entry.split('-')[0]
    fl = 0
    if usaf in station_list.keys():
        fl = 1
        coord = station_list[usaf]
        with open('data/' + entry) as file:
            tmp = file.readlines()
            for line in tmp:
                l = line.split()
                date = ''.join(l[:4])
                if date in weatherByHourList:
                    if l[6] == "-9999" or l[7] == "-9999":
                        continue
                    for iii in range (4, 12):
                        if l[iii] == "-9999":
                            l[iii] = ""
                    out_data = l[4:10]
                    out_data.append(l[11])
                    with open('output/' + date + '.csv', 'a+',) as f:
                        out = [usaf, station_list[usaf][0], station_list[usaf][1], station_list[usaf][2]] + out_data
                        f.write(','.join(out) + '\n')


print(station_list)
print(len(station_list))
```



### 2. 使用QGIS完成空间插值

使用PyQGIS提供的processing库，调用IDW空间插值的API实现插值。

```python
import os, processing, glob

extent = QgsRectangle()
extent.setXMinimum(-1225788.7785473763942719)
extent.setYMinimum(-639571.7029640320688486)
extent.setXMaximum(53952.0980498259887099)
extent.setYMaximum(685123.5293848998844624)
rect = extent
print(rect)

AirTempPath = "/Users/robert/Codings/2019/neasianaq/a/AirTemp/"
WindSpeedPath = "/Users/robert/Codings/2019/neasianaq/a/WindSpeed/"
SeaLevelPrPath = "/Users/robert/Codings/2019/neasianaq/a/SeaLevelPr/"
WindDirectionPath = "/Users/robert/Codings/2019/neasianaq/a/WindDirection/"

attrDict = {
    "AirTemp": 4,
    "SeaLevelPr": 6,
    "WindDir": 7,
    "WindSpeed": 8
}

pathDict = {
    "AirTemp": AirTempPath,
    "SeaLevelPr": SeaLevelPrPath,
    "WindDir": WindDirectionPath,
    "WindSpeed": WindSpeedPath
}

layersList = QgsProject.instance().mapLayers()
print(layersList)

flag = 1

for layername in layersList:
    lyr = layersList[layername] 
    print(lyr.name())
    if flag != 1:
        break
    if lyr.name().find("2019") != -1:
        flag = 2
        for attr in attrDict:
            layer_data=QgsInterpolator.LayerData()
            layer_data.source = lyr
            layer_data.zCoordInterpolation=False
            layer_data.interpolationAttribute = attrDict[attr] #Field
            layer_data.sourceType = 0 #points

            idw_interpolator = QgsIDWInterpolator([layer_data])
            idw_interpolator.setDistanceCoefficient(2.5)
            # export_path = AirTempPath + lyr.name() + "_AirTemp.tif"
            export_path = pathDict[attr] + lyr.name() + "_" + attr + ".tif"
            
            output = QgsGridFileWriter(idw_interpolator, export_path, rect, 750, 725)
            print(output)
            output.writeFile()
```



### 3. 计算覆盖地表的相对湿度

利用物理公式，获得相对湿度信息。

```python
from osgeo import gdal
import math
import numpy as np

class Grid(object):
    def read_img(self, _file):
        # print (_file)
        dataset = gdal.Open(_file)
        # 数据描述
        print(dataset.GetDescription())

        # 图像的列数X与行数Y
        img_width = dataset.RasterXSize
        img_height = dataset.RasterYSize

        # 仿射矩阵
        img_geotrans = dataset.GetGeoTransform()

        # 投影
        img_proj = dataset.GetProjection()

        # 将数据写成数组，对应栅格矩阵
        img_data = dataset.ReadAsArray(0, 0, img_width, img_height)

        # 数据格式大小
        print(img_data.shape)

        del dataset
        return img_data, img_proj, img_geotrans #, img_width, img_height

    def write_img(self, _file, img_data, img_proj, img_geotrans, _format):
        # 判断栅格数据的数据类型
        if 'int8' in img_data.dtype.name:
            datatype = gdal.GDT_Byte
        elif 'int16' in img_data.dtype.name:
            datatype = gdal.GDT_UInt16
        else:
            datatype = gdal.GDT_Float32

        # 判读数组维数
        if len(img_data.shape) == 3:
            img_bands, img_height, img_width = img_data.shape
        else:
            img_bands, (img_height, img_width) = 1, img_data.shape

        # 创建文件
        # HFA -> .img | GTiff -> .tif
        if _format == 'tif':
            driver = gdal.GetDriverByName("GTiff")
        else:
            driver = gdal.GetDriverByName("HFA")

        dataset = driver.Create(_file, img_width, img_height, img_bands, datatype)

        # 写入仿射变换参数
        dataset.SetGeoTransform(img_geotrans)
        # 写入投影
        dataset.SetProjection(img_proj)
        # 写入数组数据
        # GetRasterBand()
        if img_bands == 1:
            dataset.GetRasterBand(1).WriteArray(img_data)
        else:
            for i in range(img_bands):
                dataset.GetRasterBand(i + 1).WriteArray(img_data[i])

        del dataset


AirTPath = '/Users/robert/Codings/2019/neasianaq/a/Weather_Interpolated/AirTemp/'
DPoTPath = '/Users/robert/Codings/2019/neasianaq/a/Weather_Interpolated/DPTemp/'
RHPath = '/Users/robert/Codings/2019/neasianaq/a/Weather_Interpolated/RH/'

T_airList = []
T_dpoList = []

# a = 6.11
# b = 17.67
# c = 257.14
# d = 234.5
e = math.e

# def flattenImageArray(ImageArray, Width, Height)

grid = Grid()

# -------- Getting the lists ready -------
for i in range(13, 19):    # day of date
    for j in range(0, 24, 3):
        dateTime = ('201903{:0>2d}'.format(i) + '{:0>2d}').format(j)
        AFileName = dateTime + '_proj_AirTemp.tif'
        DFileName = dateTime + '_proj_DPTemp.tif'
        # T_airList.append(AFileName)
        # T_dpoList.append(DFileName)

        Ta, aProj, aGeoTrans = grid.read_img(AirTPath + AFileName)
        Td, dProj, dGeoTrans = grid.read_img(DPoTPath + DFileName)

        Ta = Ta/10
        Td = Td/10
        a = (5.0/9.0)*(Ta-32.0)
        b = (5.0/9.0)*(Td-32.0)
        c = 6.11 * np.power(10, (7.5*a/(237.7+a)))
        d = 6.11 * np.power(10, (7.5*b/(237.7+b)))
        RH = (d/c)*100

        # # Ta = gdal.Open(AirTPath + AFileName).ReadAsArray()
        # # Td = gdal.Open(DPoTPath + DFileName).ReadAsArray()
        # exponent = (d * Td)/(c + Td) - (b - Ta/d) * (Ta / (e + Ta))
        # print(exponent)
        # RH = 100 * np.power(e, exponent)
        print(RH)

        RHFileName = dateTime + '_proj_RH.tif'
        grid.write_img(RHPath + RHFileName, RH, aProj, aGeoTrans, 'tif')

        print("Calculation of Relative Humidity for " + dateTime + " is done.")
```



### 4. 将逗号分隔文本表格转化为地理信息系统支持的Shapefile

使用QGIS的processing库，遍历储存数据表格文件的文件夹并使用QGIS进行转换。

```python
import glob, os, processing

path_to_csv = "/Users/robert/Codings/2019/neasianaq/a/output/"
shape_result = "/Users/robert/Codings/2019/neasianaq/a/shps/"  # Change path to where you want the shapefiles saved

os.chdir(path_to_csv)  # Sets current directory to path of csv files
for fname in glob.glob("*.csv"):  # Finds each .csv file and applies following actions
        uri = "file:///" + path_to_csv + fname + "?delimiter=%s&crs=epsg:4326&xField=%s&yField=%s" % (",", "lon", "lat")
        name = fname.replace('.csv', '')
        lyr = QgsVectorLayer(uri, name, 'delimitedtext')
        output_name = shape_result + name + ".shp"
        QgsVectorFileWriter.writeAsVectorFormat(lyr, output_name,"utf-8", QgsCoordinateReferenceSystem("EPSG:4326"), "ESRI Shapefile", False)

for fname in glob.glob("*.shp"):
    uri = "file:///" + shape_result + fname
    name = fname.replace('.shp', '')
    lyr = QgsVectorLayer(uri, name)
```

















### Reference 参考资料

1. George Y. Lu, David W. Wong,
   An adaptive inverse-distance weighting spatial interpolation technique,
   Computers & Geosciences,
   Volume 34, Issue 9,
   2008,
   Pages 1044-1055,
   ISSN 0098-3004,
   https://doi.org/10.1016/j.cageo.2007.07.010.
2. 